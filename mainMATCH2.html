




<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        background: #121313;
 width: 99%;
        height: 95%;
        margin-left:0.2vh;
      }
#initialMenu {
    background-color: black;
    text-align: center;
          height: 94vh;
        width:99%;
color:white;
}

#initialMenu h2 {
    font-size: 3vh;
    margin-bottom: 2vh;
}
#logContainer  {
    border: 1px solid #ccc;
    border-radius: 1vh;
    background-color: yellow;
    text-align: center;
  position:absolute;
  top:60vh;
  visibility: hidden;
}


#initialMenu p {
    font-size: 2vh;
    margin: 2vh 0;
}
.speed-button {
font-size: calc(2vh + 2vw);`
  font-weight: bold;
height:9vh;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease;
}
 #countdownSpeedButtons {
  width: 100%;
}
/* Unique styles for each button */
#speed-10 {
    background-color: black;
    color: white;
    border:0.5vh solid white;
      width: 30%;

}

#speed-20 {
    background-color: black;
    color: white;
    border:0.5vh solid white;
          width: 30%;

}

#speed-30 {
    background-color: black;
    color: white;
    border:0.5vh solid white;
          width: 30%;

}
#speed-0 {
    background-color: black;
    color: white;
    border:0.5vh solid white;
      width: 90%;
      margin-top:4vh;

}
/* Hover effect for all buttons */
.speed-button:hover {
    transform: scale(0.95);
    border:0.8vh solid white;
  font-weight:bold;
}

/* Focus styles for accessibility */
.speed-button:focus {
  
}
.duration-button {
font-size: 1.8vh;`
    font-weight: bold;
    height:11vh;
    
    border: none;
    border-radius: 50%;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease;
}
      #duration-0 {
    background-color: black;
    color: TRANSPARENT;
    border: 0.4vh solid white;
      position:absolute;
  top:80%;
  left:1vh;
}    

#duration-1, #duration-2, #duration-3, #duration-4, #duration-5 {
    background-color: #292929;
    color: #FFD700;
    border: 0.4vh solid #FFD700;
  width:10vh;
}
#duration-1:hover, #duration-2:hover, #duration-3:hover, #duration-4:hover, #duration-5:hover  {
    background-color: brown;
    color: white;
    border: 0.4vh solid white;
}
.duration-button span {
    z-index: 1;
    position: relative;
}

/* The circular progress will be applied as the border */
.duration-button[data-progress] {
    position: relative;
    background: conic-gradient( #6A1B42 calc(var(--progress) * 1%), black 0);
  
}

.duration-button[data-progress]::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 0.5vh solid #6A1B42; /* Inner border to make it look like a circle */
    box-sizing: border-box;
}
button[onclick="startGameFromMenu()"] {
  background-color: black;
    color: white;
    border:0.1vh solid white;
      width: 97%;
      margin-top:4vh;
          height:11vh;
position:absolute;
  top:80%;
  left:1vh;
font-size: calc(2vh + 2vw);`

}
#container1 {
    display: flex;        margin-left:0.7vh;

    height: 80vh;    margin-top:10.5vh;
}

#questioncontainer, #translationcontainer {
    display: flex;
    flex-direction: column;  /* Arrange buttons in a column */
    justify-content: flex-start;  /* Align buttons at the top */
    flex: 1;                 /* Allow both containers to expand equally and fill available space */
    height: 100%;            /* Make each section take 100% of the parent's height */
}

#questions, #answers {
    display: flex;
    flex-direction: column;  /* Arrange buttons in a column */
    justify-content: space-between;  /* Distribute buttons vertically with space between */
    flex: 1;            
   
}

button {text-transform: uppercase;
    flex: 1;                 /* Make each button expand to fill the available height */
    height: auto;            /* Ensure buttons do not have a fixed height */
          font-size: 2.5vh;
 background-color: black;
    color: white;
    border:0.1vh solid white;
}

  #playPauseButton {
                 font-size: 4.2vh;
position:absolute;
         top:1vh;
         left:1vh;
      }



    #questioncontainer button.selected {
        background-color: darkgrey;
        color: black;
text-transform: uppercase;
    }

    /* Active selected state for answer buttons */
    #translationcontainer button.selected {
       background-color: darkgrey;
        color: black;

    }

    /* Feedback styles */
    #feedback {
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        margin-top: 20px;
        visibility: hidden;

    }

    /* Correct feedback */
    #feedback.correct {
        color: green;
    }

    /* Incorrect feedback */
    #feedback.incorrect {
        color: red;
    }

          #countdown-bar {
        height: 2vh;
        background-color: yellow;
        transition: width 1s linear;
        position:absolute;
        top:8%;
        left:1%;
        width:97.95%;
      }

      #counters {
 position:absolute;
        top:7.5%;        font-size: 2.5vh;
        color: yellow;
            text-align: left;     /* Centered text */
visibility: hidden;
      }

      #gameResult {
        position:absolute;
        top:10.5%;
        font-size: 2.5vh;
        font-weight: bold;
        color: white;
      }

      #consecutiveCounter {
        position:absolute;
        top:7.5%;
        left:30%;
        font-size: 2.5vh;
        font-weight: bold;
        color: lightgreen;
                    text-align: left;   visibility: hidden;

      }
#questionCounter {
        position:absolute;    

        top:12.5%;
        left:30%;
        font-size: 2.5vh;
        font-weight: bold;
        color: lightgreen;
                    text-align: left;   visibility: hidden;

      }
      #controlButtons {
      }

    
      #pauseBtn {
         font-size: 4vh;
        cursor: pointer;
        background-color: #420000;
        color: pink;
        width:25vh;
        height:6.2vh;
        border: 0.5vh solid pink;
        border-radius: 1vh;
       position:absolute;
        top:1vh;
        left:29vh;
       padding:0% 0%;
        font-weight:bold;
      }
#pauseBtn:hover {
       
    background-color: red; 
    color: white;    
    border: 0.5vh solid pink;   
}
      #pauseBtn[disabled] {
        background-color: #212121;
        color:white;
                border: 0.5vh solid white;
        height:6vh;

        cursor: not-allowed;
      }
      .answer-btn.disabled {
        background-color: #555; /* Greyed out color */
        color: #aaa; 
        
        border: 0.5vh solid #aaa; /* Greyed out border */
        cursor: not-allowed;
      }
        #quiz{
           width: 95%;
                  height: 100%;

}

       
        
#gameOverMessage h2 {
    font-size: 5vh;
    margin-bottom: 4vh;
    text-transform: uppercase;
    color: #f44336; /* Vibrant red for emphasis */
    text-shadow: 0.5vh 0.5vh 1vh rgba(0, 0, 0, 0.7);
}

#resultsContainer {
    text-align: center;
    font-size: 5vh;
      background: black;
  color:white;

}

#finalResults {
    border-radius: 1vh;
        font-size:5vh;
  

}

#saveScoreButton,
#returnToMenuButton,
#additionalOptions {
    margin: 3vh 0;
}

#saveScoreButton button{
    background: black; /* Green color for buttons */
    color: yellow;
font-size: calc(2vh + 2vw);`
    padding: 0.5vh 0.5vh;
    margin: 0.5vh;
            border: 0.2vh solid yellow;
animation: soft-vibrate 0.3s infinite;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 1vh 1.5vh rgba(0, 0, 0, 0.3);
}
#returnToMenuButton button{
        background-color: #420000;
    color: red;
font-size: calc(2.5vh + 2.5vw);`
    padding: 0.5vh 0.5vh;
    margin: 0.5vh;
        border: 0.2vh solid red;

    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 1vh 1.5vh rgba(0, 0, 0, 0.3);
}

#saveScoreButton button:hover{
     background-color: black;
  color:white

}
#returnToMenuButton button:hover {
     background-color: red;
  color:#420000;

}

#saveScoreButton button:active,
#returnToMenuButton button:active{
    transform: translateY(0);
    box-shadow: 0 1vh 1.5vh rgba(0, 0, 0, 0.3);
}

#additionalOptions {
    display: flex;
    flex-wrap: wrap;
    width: 100%;

    justify-content: center;
}


         #endGameScreen {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
        height: 99%;
    background-color: black;
    display: flex;
    flex-direction: column;
    color:black;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-family: 'Arial', sans-serif;
    z-index: 999;
}

#gameOverMessage h2 {
    font-size: 5vh;
    margin-bottom: 4vh;
    text-transform: uppercase;
    color: #f44336; /* Vibrant red for emphasis */
    text-shadow: 0.5vh 0.5vh 1vh rgba(0, 0, 0, 0.7);
}

#resultsContainer {
    text-align: center;
    font-size: 3.5vh;
        text-transform: uppercase;

}


#finalResults {
    background: black;
  color:white;
    border-radius: 1vh;
font-size: calc(1vh + 1vw);`
      text-transform: uppercase;

}

       

       
       #endGameBtn {
         position:absolute;
left:0.01vh;
width:20%;font-weight:bold;
               bottom:1%;
    display: inline-block; /* Ensures it behaves like a button */
 font-size: calc(2vmin + 2vmax);      background-color: darkred; /* Red background */
  color: white; /* White text color */
            border: 0.2vh solid #ff0027;
    border-radius: 5px; /* Adds rounded corners */
    cursor: pointer; /* Pointer cursor on hover */
    margin: 10px 0 0 10px; /* Adds spacing around the button */
    text-align: center; /* Centers the text inside the button */
}
         button[onclick="playCatch()"]{
}
 button[onclick="playListening()"]{
}
  button[onclick="playChoose()"]{
}
button[onclick="playVoiceRecognition()"]{
}
 #additionalOptions button {
     display: inline-block;
    width: 24%;
height:10vh;
}
       #pronounButtons {
  display: flex;
  flex-direction: row;
  justify-content: space-between; /* Adjusts spacing between buttons */
  align-items: center;
  width: 99%;
}

#pronounButtons h3 {
}

#pronounButtons button {
  flex: 1; height:8vh;
    color: white; /* Vibrant red for emphasis */
        font-weight:bold;
margin-left:0.6vh;
font-size: calc(1.6vh + 1.6vw);`
  text-align: center;
  cursor: pointer;
  border: 0.3VH solid white;
  background-color: #292929;
  box-sizing: border-box;
}

#pronounButtons button:hover {
  background-color: black; 
  color:yellow;
    border: 0.3VH solid yellow;

}

#pronounButtons button:active {
  background-color: #d0d0d0; /* Active button click effect */
}
       @keyframes rotate {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    } #settingsContent {
     
        } .settings-button { position:absolute; top:-2%; left:0vh;   font-size: 10vh;
 animation: rotate 12s linear infinite;
            background-color: transparent;
                border: 0.3VH solid transparent;

          
          
        }
      @keyframes soft-vibrate {
  0% { transform: translate(0, 0); }
  25% { transform: translate(-0.5px, 0.5px); }
  50% { transform: translate(0.5px, -0.5px); }
  75% { transform: translate(-0.5px, -0.5px); }
  100% { transform: translate(0, 0); }
}
                 label {
  position:absolute;
        top:86.5%;
        left:30%;
         color:white;
        } 
      #voiceSelect{
  position:absolute;
        top:95.5%;
        left:30%;
        } 
</style>

</head>
<body>

      <div id="initialMenu">
                 OPTIONAL SETTINGS:

        <button id="settingsButton" class="settings-button" onclick="toggleSettings()">⚙️<h2></h2></button>
        <div id="settingsContent">
            <h2>CHOOSE THE SPEED</h2>
            <div id="countdownSpeedButtons">
                <div id="speedOptions">
                    <button id="speed-50" class="speed-button" onclick="setCountdown(50, 'FAST')">FAST</button>
                    <button id="speed-80" class="speed-button" onclick="setCountdown(80, 'NORMAL')">NORMAL</button>
                    <button id="speed-100" class="speed-button" onclick="setCountdown(100, 'SLOW')">SLOW</button>
                </div>
                <div id="noCountdownOption">
                    <button id="speed-0" class="speed-button" onclick="setCountdown(0, 'NO COUNTDOWN')">NO COUNTDOWN</button>
                </div>
            </div>

            <h2>TIME TO PLAY:</h2>
            <div id="gameDurationButtons">
                <button id="duration-1" class="duration-button" onclick="setGameDuration(1)">1 Min</button>
                <button id="duration-2" class="duration-button" onclick="setGameDuration(2)">2 Min</button>
                <button id="duration-3" class="duration-button" onclick="setGameDuration(3)">3 Min</button>
                <button id="duration-4" class="duration-button" onclick="setGameDuration(4)">4 Min</button>
                <button id="duration-5" class="duration-button" onclick="setGameDuration(5)">5 Min</button>
            </div>

           <h3>CHOOSE A PRONOUN:</h3>
            <div id="pronounButtons">
                <button id="yo" onclick="togglePronoun('yo')">I</button>
                <button id="tu" onclick="togglePronoun('tu')">YOU</button>
                <button id="el" onclick="togglePronoun('el')">HE</button>
              <button id="nosotros" onclick="togglePronoun('nosotros')">WE</button>
                              <button id="vosotros" onclick="togglePronoun('vosotros')">YOU ALL</button>
                <button id="ellos" onclick="togglePronoun('ellos')">THEY</button>
            </div>
        </div>
        <button class="start-button" onclick="startGameFromMenu()">START</button>
         <button id="duration-0" class="duration-button" onclick="setGameDuration(0)">NO TIME</button>
    </div>

<div id="quiz" style="display: none;"> 
     <button id="playPauseButton">🎵</button>
<select id="voiceSelect">
    <option value=""></option>
    <!-- The options will be populated by JavaScript -->
</select>
    <div id="countdown-bar"></div>

<div id="container1">
    <!-- Section to display question buttons -->
    <div id="questioncontainer">
        <div id="questions"></div>
    </div>

    <!-- Section to display translation buttons -->
    <div id="translationcontainer">
        <div id="answers"></div>
    </div>
    </div>


        <div id="counters"></div>
    <div id="consecutiveCounter"></div> 
    <button id="pauseBtn" onclick="togglePause()">PAUSE</button>
    <button id="endGameBtn" onclick="endGame()">END GAME</button>
      <div id="feedback"></div>

</div>
<div id="logContainer">
    <h3>Mistake Log</h3>
    <textarea id="mistakeLog" rows="10" cols="50" readonly></textarea>
</div>
<div id="endGameScreen" style="display: none;">
   <div id="returnToMenuButton">
        <button onclick="resetToMenu()">BACK TO MENU</button>
    </div>
  <div id="gameOverMessage">
        <h2>RESULTS:</h2>
    </div>
     

    <div id="resultsContainer">
<div id="finalResults"></div>    </div>

    <div id="saveScoreButton">
        <button onclick="saveScore()">SAVE THIS SCORE</button>
    </div>

           <h3>PLAY WITH YOUR MISTAKES:</h3>
    <div id="additionalOptions">
  

        <button onclick="playCatch()">CATCH</button>
        <button onclick="playListening()">LISTEN</button>
        <button onclick="playChoose()">CHOOSE</button>
        <button onclick="playVoiceRecognition()">SPEAK</button>
    </div>
</div>
<script>
let settingsVisible = false;

function toggleSettings() {
    const settingsContent = document.getElementById('settingsContent');
    settingsVisible = !settingsVisible;
    settingsContent.style.display = settingsVisible ? 'block' : 'none';
}

const verbs = {
  rest: { rootEn: "REST", rootEs: "DESCANS" },
            work: { rootEn: "WORK", rootEs: "TRABAJ" },
            walk: { rootEn: "WALK", rootEs: "CAMIN" },
            study: { rootEn: "STUDY", rootEs: "ESTUDI" },
            help: { rootEn: "HELP", rootEs: "AYUD" },
            visit: { rootEn: "VISIT", rootEs: "VISIT" },
            wait: { rootEn: "WAIT", rootEs: "ESPER" },
};

const pronouns = ["yo", "tu", "el", "nosotros", "vosotros", "ellos"]; // Example pronouns
let countdownDuration = 80;
let gameDuration = null;
let selectedDurationLabel = "Unlimited"; // Default label
let selectedSpeedLabel = "80 seconds";

let usedVerbs = [];
let usedPronouns = [];
let currentQuestion = {};

let questionsPlayedCount = 0;
let timer, gameTimer;
let countdownPaused = false, quizRunning = false;

let correctAnswerCount = 0;
let incorrectAnswerCount = 0;
let delayedAnswerCount = 0; // ✅ Added for delayed correct matches
let totalAttemptsPerQuestion = new Map();
function setGameDuration(minutes) { 
    if (minutes > 0) {
        gameDuration = minutes * 60000;
        expectedQuestions = minutes * 10; // 10 correct answers per minute
        selectedDurationLabel = `${minutes} Minute${minutes > 1 ? 's' : ''}`;
    } else {
        gameDuration = null; // No time limit
        expectedQuestions = questionsPlayedCount; // Matches played questions
        selectedDurationLabel = "Unlimited";
    }

    const durationButtons = document.querySelectorAll('.duration-button');
    durationButtons.forEach(button => {
        button.style.backgroundColor = "";  // Reset background color
        button.style.transform = ""; // Reset transform (scale)
    });

    const selectedButton = document.querySelector(`#duration-${minutes}`);
    if (selectedButton) {
        selectedButton.style.backgroundColor = "red";
        selectedButton.style.transform = "scale(1.20)"; // Apply scale to selected button
    }
}

function setCountdown(seconds, label) {
    countdownDuration = seconds;

    const speedButtons = document.querySelectorAll('.speed-button');
    speedButtons.forEach(button => button.style.backgroundColor = ""); 

    const selectedButton = document.querySelector(`#speed-${seconds}`);
    if (selectedButton) selectedButton.style.backgroundColor = "lightgreen";
}

function startGameFromMenu() {
    toggleDisplay("initialMenu", false);
    toggleDisplay("quiz", true);
    startGame();
}

function resetToMenu() {
    window.location.reload();
}

function toggleDisplay(elementId, show) {
    const element = document.getElementById(elementId);
    if (element) element.style.display = show ? "block" : "none";
}

function startGame() {
    resetGameStats();
    quizRunning = true;
    usedPronouns = []; // Reset pronoun tracking at the start

    if (gameDuration) { // Only start timer if a duration is set
        gameTimer = setTimeout(endGame, gameDuration);
    }
    
    generateRandomPhrase();
}



function endGame() {
    clearInterval(timer);
    clearTimeout(gameTimer);
    quizRunning = false;

    toggleDisplay("quiz", false);
    toggleDisplay("endGameScreen", true);
    toggleDisplay("counters", true);
    toggleDisplay("consecutiveCounter", true);
    toggleDisplay("questionCounter", true);

    let totalPlayed = correctAnswerCount + incorrectAnswerCount + delayedAnswerCount;
    let accuracy = totalPlayed > 0 
        ? (correctAnswerCount / totalPlayed) * 100 
        : 0;

    document.getElementById("finalResults").innerHTML = `
        <p>Questions Played: ${totalPlayed}</p>
        <p>Correct Matches: ${correctAnswerCount}</p>
        <p>Incorrect Matches: ${incorrectAnswerCount}</p>
        <p>Delayed Matches: ${delayedAnswerCount}</p>
        <p><strong>SCORE: ${Math.round(accuracy)}%</strong></p>
    `;
}

function saveScore() {
    let totalPlayed = correctAnswerCount + incorrectAnswerCount + delayedAnswerCount;
    let qualification = totalPlayed > 0 
        ? (correctAnswerCount / totalPlayed) * 100 
        : 0;

    const roundedScore = Math.round(qualification);
    const durationKey = `duration-${gameDuration / 60000}`;

    // Save both the score and total questions played with a unique namespace
    localStorage.setItem(`matching-${durationKey}-score`, roundedScore);
    localStorage.setItem(`matching-${durationKey}-played`, totalPlayed);

    alert(`Score of ${roundedScore}% saved for duration ${gameDuration / 60000} min. (${totalPlayed} questions played)`);

    resetToMenu();
}

function updateMenuWithScores() { 
    const durationButtons = document.querySelectorAll('.duration-button');
    durationButtons.forEach(button => {
        const duration = button.id.split('-')[1]; 
        const durationKey = `duration-${duration}`;

        // Retrieve saved score with a unique namespace
        const savedScore = localStorage.getItem(`matching-${durationKey}-score`);

        if (savedScore !== null) {
            button.innerHTML = `${duration} Min <span style="color: yellow;">${savedScore}%</span>`;
            button.style.setProperty('--progress', savedScore); // Update the custom property
            button.setAttribute('data-progress', savedScore); 
        }
    });
}

document.addEventListener('DOMContentLoaded', updateMenuWithScores);
function updateHighestMatchingScore() {
    let highestScore = 0;

    // Select all duration buttons
    const durationButtons = document.querySelectorAll('.duration-button');

    durationButtons.forEach(button => {
        const scoreSpan = button.querySelector('span');

        if (scoreSpan) {
            // Extract the numerical score from the button text
            const scoreText = scoreSpan.textContent.replace('%', '').trim();
            const score = parseInt(scoreText, 10);

            if (!isNaN(score) && score > highestScore) {
                highestScore = score;
            }
        }
    });

    // Store the highest score in localStorage with the correct key
    localStorage.setItem("score-matching", highestScore);

    // Update the button span with the highest score
    updateScoreDisplay("score-matching", "score-value-matching");
}

// Ensure scores are updated first, then find the highest score
document.addEventListener("DOMContentLoaded", function () {
    updateMenuWithScores(); // Update duration buttons first
    setTimeout(updateHighestMatchingScore, 100); // Fix the function name here
});


function resetGameStats() {
    usedVerbs = [];
    usedPronouns = [];
    correctAnswerCount = 0;
    incorrectAnswerCount = 0;
    delayedAnswerCount = 0; // Added to track delayed matches
    notAnsweredCount = 0;
    consecutiveCorrectAnswers = 0;
    maxConsecutiveCorrectAnswers = 0;
    questionsPlayedCount = 0;
}
let selectedPronouns = [];


function togglePronoun(pronoun) {
    const button = document.getElementById(pronoun);

    const isAlreadySelected = selectedPronouns.includes(pronoun);
    if (isAlreadySelected) {
        selectedPronouns = selectedPronouns.filter(p => p !== pronoun);
        button.style.backgroundColor = ""; 
        button.style.color = ""; 
    } else {
        selectedPronouns.push(pronoun);
        button.style.backgroundColor = "brown"; 
        button.style.color = "white"; 
    }

    console.log("Selected Pronouns:", selectedPronouns);
    generateRandomPhrase();
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; 
    }
    return array;
}

function generateQuestions(verb, pronoun) {
    const { rootEn, rootEs } = verb;

     const storedQuestions = localStorage.getItem("questionsData");

let questionSets = {}; // Inicializamos vacío por si no hay datos

if (storedQuestions) {
    // Convertimos el JSON en un objeto
    questionSets = JSON.parse(storedQuestions);
}

// Ahora questionSets tiene los datos cargados y mantiene la estructura esperada

    const questionSet = questionSets[pronoun] || [];
    
    questionSet.forEach(item => {
        item.translations = [item.translation];  // Put the correct translation in an array
    });

    shuffleArray(questionSet);  // Shuffle the translation buttons

    return questionSet;
}
let currentQuestions = []; // Store all current questions and translations
let matchedQuestions = []; // Store matched questions to track progress
let selectedQuestion = null; // Store the question that was clicked by the user

let lastSelectedPronoun = null; // Store the last chosen pronoun

function generateRandomPhrase() {
    if (usedVerbs.length === Object.keys(verbs).length) usedVerbs = [];

    // If no pronoun is selected, use all pronouns equally
    let availablePronouns = selectedPronouns.length > 0 ? selectedPronouns : [...pronouns];

    // Pick a pronoun randomly but distribute usage evenly
    let randomPronoun = pickRandom(availablePronouns, usedPronouns);
    
    // Ensure the pronoun is recorded as used
    if (!usedPronouns.includes(randomPronoun)) {
        usedPronouns.push(randomPronoun);
    }

    // Check if all pronouns have been used
    if (usedPronouns.length === pronouns.length) {
        endGame(); // Trigger game ending if all pronouns were used
        return;
    }

    // Pick a new random verb
    const randomVerbKey = pickRandom(Object.keys(verbs), usedVerbs);
    const selectedVerb = verbs[randomVerbKey];

    // Randomly select one of the question sets for the chosen pronoun
    const generatedQuestions = generateQuestions(selectedVerb, randomPronoun); 

    // Store the last selected pronoun only if pronouns were manually chosen
    lastSelectedPronoun = selectedPronouns.length > 0 ? randomPronoun : null;

    // Flatten the array of questions
    currentQuestions = generatedQuestions.flat();
    matchedQuestions = [];

    // Display questions and translations
    displayAllQuestions(currentQuestions);
    createTranslationButtons(currentQuestions.map(q => q.translation));

    // Reset countdown
    resetCountdown();

    // Update the questions played count
    questionsPlayedCount++;
    document.getElementById("questionCounter").textContent = `Questions Played: ${questionsPlayedCount}`;
}


// Helper function to ensure equal distribution
function pickRandom(array, usedArray) {
    let available = array.filter(item => !usedArray.includes(item));
    
    if (available.length === 0) { 
        usedArray.length = 0; // Reset if all have been used
        available = [...array];
    }
    
    const choice = available[Math.floor(Math.random() * available.length)];
    usedArray.push(choice); // Mark as used
    return choice;
}
let selectedPair = { question: null, translation: null }; // Store clicked elements

function selectItem(item, type) {
    if (type === "question") {
        selectedPair.question = item;
    } else if (type === "translation") {
        selectedPair.translation = item;
    }

    // If both are selected, check the answer
    if (selectedPair.question && selectedPair.translation) {
        checkAnswer();
    }
}

function displayAllQuestions(questions) {
    const questionsDiv = document.getElementById("questions");
    questionsDiv.innerHTML = ''; // Clear previous questions

    questions.forEach((questionObj) => {
        const button = document.createElement("button");
        button.className = "question-btn";
        button.textContent = questionObj.question;
        button.onclick = () => selectItem(questionObj, "question");
        questionsDiv.appendChild(button);
    });
}

// Function to create translation buttons for all the questions
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
}

function createTranslationButtons(translations) {
    const answersDiv = document.getElementById("answers");
    answersDiv.innerHTML = ''; // Clear previous translations

    shuffleArray(translations); // Shuffle the translations array

    translations.forEach(translation => {
        const button = document.createElement("button");
        button.className = "answer-btn";
        button.textContent = translation;
        button.onclick = () => selectItem(translation, "translation");
        answersDiv.appendChild(button);
    });
}

function selectButton(event, containerId) {
    const button = event.target;
    // Ensure the clicked element is a button
    if (button.tagName === 'BUTTON') {
        // Get the container element
        const container = document.getElementById(containerId);

        // Remove 'selected' class from all buttons in the container
        const buttons = container.querySelectorAll('button');
        buttons.forEach(btn => btn.classList.remove('selected'));

        // Add 'selected' class to the clicked button
        button.classList.add('selected');
    }
}

// Function to unselect all buttons in a container (for mistakes)
function unselectAllButtons(containerId) {
    const container = document.getElementById(containerId);
    const buttons = container.querySelectorAll('button');
    buttons.forEach(btn => {
        btn.classList.remove('selected'); // Remove 'selected' class
        btn.style.backgroundColor = ''; // Reset background color if it's changed
    });
}

// Event delegation for question buttons (for dynamically added buttons too)
document.getElementById('questioncontainer').addEventListener('click', function(event) {
    selectButton(event, 'questioncontainer');
});

// Event delegation for translation buttons (for dynamically added buttons too)
document.getElementById('translationcontainer').addEventListener('click', function(event) {
    selectButton(event, 'translationcontainer');
});


function handleMistake(questionButton, translationButton) {
 // Apply styles for selection effect
questionButton.style.backgroundColor = "black";
questionButton.style.color = "#FF3131";
questionButton.style.border = "0.2vh solid #FF3131";
questionButton.style.textShadow = "0.7px 0.7px 1.5px #ff3100"; // White text shadow

translationButton.style.backgroundColor = "black";
translationButton.style.color = "#FF3131";
translationButton.style.border = "0.2vh solid #FF3131";
translationButton.style.textShadow = "0.7px 0.7px 1.5px #ff3100"; // White text shadow

// Apply vibration effect
questionButton.style.animation = "soft-vibrate 0.3s infinite ease-in-out";
translationButton.style.animation = "soft-vibrate 0.3s infinite ease-in-out";

setTimeout(() => {
    // Reset styles to original
    questionButton.style.backgroundColor = "";
    questionButton.style.color = "";
    questionButton.style.border = "";
    questionButton.style.animation = "";
    questionButton.style.textShadow = "";

    translationButton.style.backgroundColor = "";
    translationButton.style.color = "";
    translationButton.style.border = "";
    translationButton.style.animation = "";
    translationButton.style.textShadow = "";

    // Ensure proper unselection
    unselectAllButtons('questioncontainer');
    unselectAllButtons('translationcontainer');
}, 1000);


}

let selectedVoice = null;

// Populate voice selection dropdown
function populateVoiceList() {
    const voiceSelect = document.getElementById("voiceSelect");
    voiceSelect.innerHTML = ""; // Clear previous options

    const voices = speechSynthesis.getVoices();
    const spanishVoices = voices.filter(voice => voice.lang.startsWith("es"));

    // Add Spanish voices to the dropdown
    spanishVoices.forEach((voice, index) => {
        const option = document.createElement("option");
        option.value = index; // Save the index for reference
        option.textContent = `${voice.name} (${voice.lang})`;
        voiceSelect.appendChild(option);
    });

    // Set default selected voice (first available)
    if (spanishVoices.length > 0) {
        selectedVoice = spanishVoices[0]; // Default to the first voice
    }
}

// Listen for changes in dropdown selection
document.getElementById("voiceSelect").addEventListener("change", function() {
    const voices = speechSynthesis.getVoices();
    const spanishVoices = voices.filter(voice => voice.lang.startsWith("es"));
    selectedVoice = spanishVoices[this.value]; // Update selected voice
});

// Ensure voices load properly
speechSynthesis.onvoiceschanged = populateVoiceList;
populateVoiceList(); // Call initially

function checkAnswer() {  
    if (!quizRunning || !selectedPair.question || !selectedPair.translation) return;

    const feedbackElement = document.getElementById("feedback");
    const mistakeLog = document.getElementById("mistakeLog");

    const questionButtons = document.querySelectorAll("#questions button");
    const translationButtons = document.querySelectorAll("#answers button");

    const questionButton = Array.from(questionButtons).find(button => button.textContent === selectedPair.question.question);
    const translationButton = Array.from(translationButtons).find(button => button.textContent === selectedPair.translation);

    let questionText = selectedPair.question.question;
    
    // Track attempts for this question
    if (!totalAttemptsPerQuestion.has(questionText)) {
        totalAttemptsPerQuestion.set(questionText, 0);
    }
    totalAttemptsPerQuestion.set(questionText, totalAttemptsPerQuestion.get(questionText) + 1);
    
    if (selectedPair.translation === selectedPair.question.translation) {
        if (!matchedQuestions.includes(selectedPair.question)) {
            // If this was the first correct attempt
            if (totalAttemptsPerQuestion.get(questionText) === 1) {
                correctAnswerCount++;
            } else {
                delayedAnswerCount++; // This was correct but only after mistakes
            }
        }

        feedbackElement.className = "correct";
        feedbackElement.textContent = "Correct";
        matchedQuestions.push(selectedPair.question);

        questionButton.style.backgroundColor = "black";
        questionButton.style.color = "lime";
        questionButton.style.border = "0.2vh solid lime";

        translationButton.style.backgroundColor = "black";
        translationButton.style.color = "lime";
        translationButton.style.border = "0.2vh solid lime";

        setTimeout(() => {
            questionButton.style.display = "none";
            translationButton.style.display = "none";
            selectedPair = { question: null, translation: null }; // Reset selection
        }, 1000);

        const utterance = new SpeechSynthesisUtterance(selectedPair.question.translation);
        utterance.lang = 'es-ES';

        // Use the selected voice
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }

        speechSynthesis.speak(utterance);

        if (matchedQuestions.length === currentQuestions.length) {
            setTimeout(generateRandomPhrase, 1000);
        }
    } else {
        // Incorrect match
        feedbackElement.className = "incorrect";
        feedbackElement.textContent = "Incorrect";
        handleMistake(questionButton, translationButton);
        incorrectAnswerCount++;

        // Log the mistake if it doesn't already exist
        const mistakeEntry = {
            question: selectedPair.question.question,
            translation: selectedPair.question.translation
        };

        let currentLog = mistakeLog.value ? JSON.parse(mistakeLog.value) : [];
        const exists = currentLog.some(entry => 
            entry.question === mistakeEntry.question && entry.translation === mistakeEntry.translation
        );

        if (!exists) {
            currentLog.push(mistakeEntry);
            mistakeLog.value = JSON.stringify(currentLog, null, 2);
        }

        updateCounters();

        setTimeout(() => {
            feedbackElement.textContent = "";
        }, 2000);
    }

    // Reset after checking
    selectedPair = { question: null, translation: null };
}

function updateCounters() {
    document.getElementById("counters").innerHTML = `
        Correct Matches: ${correctAnswerCount}<br>
        Incorrect Matches: ${incorrectAnswerCount}<br>
        Delayed Matches: ${delayedAnswerCount}
    `;
}

function resetCountdown() {
    clearInterval(timer);
    if (!countdownDuration) return;

    let width = 80;
    const countdownBar = document.getElementById("countdown-bar");
    countdownBar.style.width = "95%";

    timer = setInterval(() => {
        if (countdownPaused) return;

        width -= 80 / countdownDuration;
        countdownBar.style.width = `${width}%`;

        if (width <= 0) {
            clearInterval(timer);
            notAnsweredCount++;
            consecutiveCorrectAnswers = 0;
            updateCounters();
            const feedbackElement = document.getElementById("feedback");
            feedbackElement.textContent = "Time's up!";
            
            setTimeout(() => {
                feedbackElement.textContent = ""; // Clear the message after 1 second
                generateRandomPhrase();
            }, 1000);
        }
    }, 1000);
}
    function togglePause() {
        countdownPaused = !countdownPaused;
        document.getElementById("pauseBtn").textContent = countdownPaused ? "CONTINUE" : "PAUSE";
    }
  function playCatch() {
    const mistakeLog = document.getElementById("mistakeLog").value;
    if (mistakeLog) {
        const parsedData = JSON.parse(mistakeLog);

        localStorage.setItem('mistakeData', JSON.stringify(parsedData));

        window.location.href = 'catch.html';
    } else {
        alert("No mistakes logged to play catch!");
    }
}

function playListening() {
    const mistakeLog = document.getElementById("mistakeLog").value;
    if (mistakeLog) {
        const parsedData = JSON.parse(mistakeLog);

        localStorage.setItem('mistakeData', JSON.stringify(parsedData));

        window.location.href = 'listen.html';
    } else {
        alert("No mistakes logged to play listening!");
    }
}

function playChoose() {
    const mistakeLog = document.getElementById("mistakeLog").value;
    if (mistakeLog) {
        const parsedData = JSON.parse(mistakeLog);

        localStorage.setItem('mistakeData', JSON.stringify(parsedData));

        window.location.href = 'choose.html';
    } else {
        alert("No mistakes logged to play choose!");
    }
}

function playVoiceRecognition() {
    const mistakeLog = document.getElementById("mistakeLog").value;
    if (mistakeLog) {
        const parsedData = JSON.parse(mistakeLog);

        localStorage.setItem('mistakeData', JSON.stringify(parsedData));

        window.location.href = 'voicerecognition.html';
    } else {
        alert("No mistakes logged for voice recognition!");
    }
}
function makeAllButtonsResponsiveToBeat() {
  let audioContext, analyser, dataArray, isPlaying = false;
  let audio = null; // Declare the audio variable globally

  // Set the default audio URL if no duration button is clicked
  const defaultAudioUrl = "https://cdn.glitch.global/30d0db25-b202-45bb-b635-9b58601a408e/J.Rabbit%20-%20Tequila_%20Remix(MP3_160K)_1.mp3?v=1737651634075";

  function initializeAudioContext(audioUrl) {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    audio = new Audio(audioUrl);
    audio.crossOrigin = "anonymous";
    audio.loop = true;

    const source = audioContext.createMediaElementSource(audio);
    source.connect(analyser);
    analyser.connect(audioContext.destination);
  } else {
    // Change the audio source if already initialized
    audio.src = audioUrl;
  }
}
  function visualize() {
    if (!isPlaying) return; // Stop visualization if not playing
    requestAnimationFrame(visualize);
    analyser.getByteFrequencyData(dataArray);

    // Calculate the average volume
    const avg = dataArray.reduce((sum, val) => sum + val, 0) / dataArray.length;

    // Scale based on volume
    const scale = 0.7 + avg / 400; // Adjust the scale to make it smoother

    // Apply the scale to all buttons except the Play/Pause button
    document.querySelectorAll("button").forEach((button) => {
      if (button.id !== "playPauseButton") {
        button.style.transform = `scale(${scale})`;
      }
    });
  }

  // Add functionality to the Play/Pause button
  const playPauseButton = document.getElementById("playPauseButton");
 playPauseButton.addEventListener("click", () => {
  if (audioContext.state === "suspended") {
    audioContext.resume(); // Resume if the context is suspended
  }

  if (!isPlaying && audio) {
    audio.play();
    playPauseButton.textContent = "🔇";
    isPlaying = true;
    visualize(); // Start visualization
  } else {
    audio.pause();
    playPauseButton.textContent = "🎵";
    isPlaying = false;
  }
});

  // Initialize with the default audio URL on page load
  initializeAudioContext(defaultAudioUrl);

  // Add functionality to each duration button
  const durationButtons = document.querySelectorAll(".duration-button");
  durationButtons.forEach((button) => {
    button.addEventListener("click", () => {
      // Change the audio URL based on the clicked button's ID
      const audioUrls = {
        "duration-1": "https://cdn.glitch.global/fd235a8b-e271-4778-ad80-0ff4ed9ff6e3/videoplayback%20(2)-%5BAudioTrimmer.com%5D%20(1).m4a?v=1738030195381",
        "duration-2": "https://cdn.glitch.global/2e6f8978-0e3b-4ebb-88a3-4f57aa5374d7/videoplayback%20(3)-%5BAudioTrimmer.com%5D%20(2)-%5BAudioTrimmer.com%5D.m4a?v=1738290978314",
        "duration-3": "https://cdn.glitch.global/fd235a8b-e271-4778-ad80-0ff4ed9ff6e3/(FREE)%20Mexican%20x%20Spanish%20Guitar%20Type%20Beat%20-%20%20FIESTA%20%20%F0%9F%8C%B6%EF%B8%8F.mp4?v=1738035038669",
        "duration-4": "https://cdn.glitch.global/2e6f8978-0e3b-4ebb-88a3-4f57aa5374d7/Pruebalo%20(Instrumental).mp3?v=1738292501815",
        "duration-5": "https://cdn.glitch.global/2e6f8978-0e3b-4ebb-88a3-4f57aa5374d7/M%C3%8BSTIZA%20Live%20%26%20DJ%20session%20in%20tablao%20flamenco%20performing%20Compa%C3%B1era.mp3?v=1738203150261"
    };
function preloadAudio(url) {
  const audio = new Audio(url);
  audio.preload = 'auto'; // Preload the audio to avoid delays
  return new Promise((resolve, reject) => {
    audio.oncanplaythrough = () => resolve(audio); // Resolves when audio is ready to play
    audio.onerror = () => reject(new Error('Error loading audio file: ' + url));
  });
}

window.onload = async function () {
  try {
    const audioPromises = Object.values(audioUrls).map((url) => preloadAudio(url));
    await Promise.all(audioPromises);
    console.log("All audio files are preloaded and ready.");
  } catch (error) {
    console.error("Error preloading audio files:", error);
  }
};
      const audioUrl = audioUrls[button.id];
      if (audioUrl && !isPlaying) {
        // Only update the audio source if audio is not already playing
        initializeAudioContext(audioUrl);
      }
    });
  });
}

// Call the function to make buttons responsive to the beat
makeAllButtonsResponsiveToBeat();

// Add dynamic buttons functionality
const addButton = document.getElementById("addButton");
let buttonCount = 1;

addButton.addEventListener("click", () => {
  const newButton = document.createElement("button");
  newButton.textContent = `Dynamic Button ${buttonCount++}`;
  document.body.appendChild(newButton);
});
  
        
</script>


</body>
</html>